\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper]{geometry}
\usepackage{titling}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{lmodern}
\usepackage{tikz}
\usepackage{minted}

\newcommand{\cmdinline}[1]{\mintinline{cmdlexer.py:CommandLexer -x}{#1}}
\newcommand{\cmdline}[1]{\mint{cmdlexer.py:CommandLexer -x}{#1}}
\newcommand{\bashinline}[1]{\mintinline{bash}{#1}}
\newcommand{\bashline}[1]{\mint{bash}{#1}}

\usemintedstyle{emacs}

\setlength{\droptitle}{-10em}
\renewcommand{\familydefault}{\sfdefault} 

\title{Linux Command Sheet}
\author{Florian Weingartshofer}
\date{\today}


\begin{document}
\maketitle
\tableofcontents{}
\newpage
\section{Basics}
\subsection{User \& Kernelspace}
\begin{tikzpicture}
  \tikzstyle{arrow} = [thick,->,>=stealth]

  %% USER SPACE
  % Left Label
  \node [draw=none] at (0,0) {User Space};
  % GNU
  \node [draw=none] at (7, 1.5) {Users (Multi-User)};
  \draw [rounded corners, fill=green!25] (3, 1) rectangle (11, -1);
  \node [draw=none] at (7, 0.8) {Programs};
  % Shell
  \draw [fill=yellow!25] (3.5, 0.5) rectangle (10.5, 0);
  \node [draw=none] at (7, 0.25) {Shell};
  % Add-Ons
  \draw (3.5, -0.1) rectangle (5, -0.6);
  \node [draw=none] at (4.25, -0.35) {Add-Ons};
  % Command & Utilities
  \draw [fill=yellow!25] (5.1, -0.1) rectangle (8.6, -0.6);
  \node [draw=none] at (6.85, -0.35) {Commands \& Utilities};
  % X/Desktops
  \draw [fill=yellow!25] (8.7, -0.1) rectangle (10.5, -0.6);
  \node [draw=none] at (9.6, -0.35) {X/Desktops};
  % libc
  \draw [rounded corners, fill=green!25] (7, -1.5) rectangle (11, -2.5);
  \draw [fill=yellow!25] (7.2, -1.75) rectangle (10.8, -2.25);
  \node [draw=none] at (9, -2.05) {GNU C Library (libc)};
  \draw [line width=1mm] (9,-1.5) -- (9, -1);
  
  % Seperator
  \draw [thick,dashed] (-1,-3) -- (14,-3);
  
  % Left Label
  \node [draw=none] at (0,-6) {Kernel Space};
  % Kernel
  \draw [rounded corners, fill=red!25] (3, -3.5) rectangle (11, -8);
  \node [draw=none] at (7, -3.7) {Kernel};
  % System Call Interface
  \draw [fill=yellow!25] (3.5, -4) rectangle (10.5, -4.5);
  \node [draw=none] at (7, -4.25) {System Call Interface};
  \draw [line width=1mm] (9,-2.5) -- (9, -4);
  \draw [line width=1mm] (5,-1) -- (5, -4);
  % Management
  \draw [fill=yellow!25] (3.5, -5) rectangle (10.5, -6);
  \node [draw=none,align=left] at (4.5, -5.5) {Process\\Management};
  \node [draw=none,align=left] at (6.5, -5.5) {Memory\\Management};
  \node [draw=none] at (7.9, -5.3) {File System};
  \node [draw=none] at (9.5, -5.25) {Network};
  % Drivers
  \draw [fill=yellow!25] (3.5, -6.5) rectangle (10.5, -7.5);
  \node [draw=none] at (7, -6.75) {Architecture Dependant Code};
  \node [draw=none] at (7, -7.25) {Device Drivers};

  % Hardware
  \node [draw=none] at (7, -8.5) {Hardware};
  
  % Outer Box
  \draw (2,2) rectangle (12,-9);
\end{tikzpicture}

\subsection{Filesystem}
Das Linux Filesystem beginnt bei Root (der Pfad lautet: \cmdinline{/}).
Von dort beginnt jeder absolute Pfad.\\
Wenn man ein Terminal startet ist man normalerweiße im Home Directory (\cmdinline{/home/<username>/}).

\subsubsection{Home Directory}
Jeder User hat ein Home Directory, dieses enthält Files welche nur für diesen User gelten, zb Configs, Bilder oder Dokumente.
Das Home Directory liegt in \cmdinline{/home/<username>/}
oder unter der Environment Variable \cmdinline{$HOME}.

\subsubsection{Die Tilde}
In den meisten Shells, wie die Bash, führt die Tilde (\cmdinline{~}) direkt ins Home Directory des Users.
Allerdings hat sie noch andere Funktionen.

\cmdline{~<username>}
Home Directory von <username>.

\cmdline{~-}
Das vorherige Working Directory.

\cmdline{~+}
Das momentane Working Directory.
\\\\
Weiter Infos:
\href{https://stackoverflow.com/questions/998626/meaning-of-tilde-in-linux-bash-not-home-directory}{https://stackoverflow.com}

\subsection{Files und Directories}
\cmdline{file.docx}
Ein normales File.

\cmdline{stuff/}
Ein normales Directory, diese enden immer auf ein \cmdinline{/}.

\cmdline{.hidden.txt}
Ein verstecktes File, sie beginnen immer mit einem Punkt.

\cmdline{.hidden_dir/}
Ein verstecktes Directory beginnt auch mit einem Punkt.

\cmdline{.}
Ein Punkt zeigt nur das momentane Directory an.

\cmdline{..}
Zwei Punkte zeigen das Parent-Directory an.

\subsection{Wichtige Files und Directories}
Folgende Files und Directories können im \cmdinline{$HOME} Directory gefunden werden.
\subsubsection{.bashrc}
Das \cmdinline{.bashrc} File ist ein Bash-Script, welches beim öffnen eines Terminals ausgeführt wird.
Man kann es nutzen um Environment Variablen, Aliases zu setzen oder andere Einstellungen vorzunehmen.
Es können auch Splashscreens oder Nachrichten ausgegeben werden.

\begin{minted}{cmdlexer.py:CommandLexer -x}
  echo "Das heutige Wetter"
  curl wttr.in # Download the weather
\end{minted}

\subsubsection{.zshrc}
Ein Init Script für die Z-Shell. Hat die selbe Funktionalität wie das \cmdinline{.bashrc}.

\subsubsection{.config/}
Das \cmdinline{.config/} Directory ist ein Ordner im \cmdinline{.config/}
In diesem Directory werden einige Config-Files gespeichert.

\subsubsection{.profile}
Dieses File befindet sich im Home-Directory jedes Benutzers, es existiert auch ein globals in \cmdinline{/etc/profile}.
Es wird von der Bash und oft auch von Desktop-Environments ausgeführt.

\subsection{Aufbau eines Commands}
Ein Command besteht aus verschiedenen Komponenten:

\begin{minted}{cmdlexer.py:CommandLexer -x}
ls --all -l /home/
\end{minted}

\cmdline{ls} Das Command selbst

\cmdline{--all}
Eine ausgeschriebene Option, diese beginnen mit einem doppeltem Minus.

\cmdline{-l}
Die Kurzform einer Option, wird nur mit einem Minus geschrieben.

\cmdline{/home/}
Ein Argument, manche Commands können mehrere Argumente erhalten.

\subsection{Adminrechte}
Um einen Befehl als Admin auszuführen muss der \cmdinline{sudo} Befehl genutzt werden.

\cmdline{sudo <Befehl>}

\noindent
Beispiel:
\cmdline{sudo rm <file>}

\subsection{Navigieren}
Mit \cmdinline{cd} kann im Terminal navigiert werden.

\cmdline{cd path/to/dir/}
In ein Directory wechseln.

\cmdline{cd}
Wechselt ins Home-Directory.

\cmdline{cd ..}
Ins Parent-Directory wechseln.

\cmdline{cd -}
Ins vorherige Directory wechseln.

\subsection{Files auflisten}
\cmdline{pwd}
Zeigt absoluten Pfad zum momentanen Directory an.

\cmdline{ls}
Zeigt Files und Directories im momentanen Ordner an.

\cmdline{ls <directory>}
Zeigt Files in einem Directory an.

\cmdline{ls -l}
Zeigt Files, etc in einer Listenstruktur an.

\cmdline{ls -a}
Zeigt \textbf{alle} Files und Ordner an, auch versteckte.

\cmdline{ls -h}
Zeigt alle von Menschen lesbare Dateien und Directories an.

\cmdline{ls -la}
Es können auch verschiedene Optionen kombiniert werden.

\subsection{Erstellen von Directories}

\cmdline{mkdir <directory>}
Ein Directory im momentanen Directory erstellen.

\cmdline{mkdir /path/to/dir/newdir/}
Es kann auch ein Directory mit einem Pfad angegeben werden.

Dabei ist das letzte Directory, dass das nur erstellt wird.

\cmdline{mkdir -p new/dir}
Mit der p-Flag können auch Subdirectories rekursiv erstellt werden.

\cmdline{mkdir {dir1,dir2,dir3}}
Mit den geschwungene Klammern können mehrer Directories gleichzeitig erstellt werden.

\cmdline{mkdir -p new/{dir1,dir2,dir3}}
Die Directories können auch rekursiv in einem Parent-Directory erstellt werden.

\subsection{Erstellen von Files}

\cmdline{touch </path/to/file.txt>}
Mit \cmdinline{touch} kann ein File erstellt werden.

Falls das File schon exisitiert wird das Datum aktualisiert.

\cmdline{touch {file1,file2,file3}}
So können mehrere Files erstellt werden.

\subsection{Files Löschen}
\cmdline{rm <file>}
Mit \cmdinline{rm} kann ein oder mehrere Files löschen.

\cmdline{rm -r <dir/>}
Mit der r-Flag können auch Directories entfernt werden.

\cmdline{rm -f <file>}
Um ein File zwingend zu löschen wird die f-Flag benötigt.

\subsection{Files verschieben}
\cmdline{mv <arg1> <arg2>}
Mit \cmdinline{mv} kann ein File oder Directory verschoben oder umbenannt werden.

Vergleichbar mit Cut and Paste.

\subsection{Files kopieren}
\cmdline{cp <path/to/file.txt> <path/to/new/file>}

Mit \cmdinline{cp} können Files oder Directories kopiert werden.

\subsection{Alias}
Mit Aliases kann man Commands abkürzen.

\cmdline{alias hello='clear && echo "Hello"'}

\subsection{dos2unix}
\cmdinline{dos2unix} ist kein Standardpaket und muss daher installiert werden.
Es ist ein einfaches Tool, um DOS(Windows) Newlines zu Unix Newlines zu konvertieren. 

\section{Packagemanager}
Im Gegensatz zu Windows braucht man bei Linux keine Software manuell runterzuladen.
Dies wird automatisch mit einem Packagemanager gemacht.

\subsection{apt}
Das Advanced Packaging Tool(\cmdinline{apt}) ist ein Tool um Packages auf Debian, Ubuntu, etc zu installieren.

\subsubsection{Packages installieren}
Um ein Package zu installieren werden meistens Admin Rechte benötigt,
daher muss vor dem Command ein \cmdinline{sudo} geschrieben werden.

\cmdline{apt install <Package_1 Package_2 ... Package_n>}

\subsubsection{Packages suchen}
\cmdline{apt search <Package>}

\subsubsection{Packages entfernen}
Dieses Command muss auch als Super User ausgeführt werden.
\cmdline{apt remove <Package>}

\section{Scripting und Textverarbeitung}
\subsection{Piping}
Um Output als Input für ein anderes Programm zu nutzen, muss die Pipe verwendet werden (\cmdinline{|}).

\subsection{Ausgabeumleitung}
Output kann auch in verschiedene Files umgeleitet werden, diese werden automatisch angelegt:
\begin{minted}{cmdlexer.py:CommandLexer -x}
  echo "Hello" > hello.txt  # Das File wird komplett überschrieben beim Umleiten.
  echo "Hello" >> hello.txt # Der Text wird am Ende des Files angefügt,
                            # sollte es schon Daten beinhalten.
\end{minted}

Man kann auch verschieden Outputs umleiten, wie stderr oder stdout.
\begin{minted}{cmdlexer.py:CommandLexer -x}
  ls dir/ 1> file.txt # Redirect den standard out ins file.txt
  ls not/existing/dir/ 2> file.txt # Redirect standard error ins file.txt
\end{minted}

\subsection{Text-Editing Tools}
Folgende Tools können zum manipulieren von Texten verwendet werden, speziell für CSV Files sind diese nützlich.
Die meisten dieser Tools sind einheitlich aufgebaut:
\cmdline{wc -l path/to/text/file}
Als erstes wird das Command eingegeben, dann verschiedene Optionen und schluss endlich das Textfile, welches genutzt wird.
\subsubsection{wc}
Ein einfaches Tool zum Zählen von Zeichen, Zeilen, Wörtern, etc.
\begin{minted}{cmdlexer.py:CommandLexer -x}
  wc -l ./file # Zählt die Zeilen des Files
  wc -w ./file # Anzahl der Wörter
  man wc # Für weitere Optionen
\end{minted}

\subsubsection{tail}
Ein Tool um die letzten n-Zeilen eines Files auszugeben.
\cmdline{tail -n3 ./file }
\noindent
Die Wörter in der letzten Zeile zählen:
\cmdline{tail -n1 ./file | wc -w }

\subsubsection{head}
Mit diesen Tool können die Anfangszeilen eines Files ausgegeben werden.
\cmdline{head -n3 ./file # Die ersten drei Zeilen }
\cmdline{head -3l ./file # Ident mit der -n Option }

\subsubsection{cut}
\cmdinline{cut} entfernt bestimmte Felder einer Datei, diese ist meist im CSV Format.
Das Standardtrennzeichen ist ein Tab. Die Datei wird dabei nicht verändert.
\cmdline{cut -d'|' -f1,3 ./file }
\noindent
\cmdinline{-d';'} setzt das Trennzeichen auf ein Semicolon.\\
\cmdinline{-f1,3} Wählt das erste und dritte Feld aus.

\subsubsection{sort}
\cmdinline{sort} sortiert ein File zeilenweise.
\cmdline{sort -t'|' -k1 -r -n ./file }
\noindent
\cmdline{-t'|'} Setzt das Trennzeichen auf eine Pipe.
\cmdline{-k1} Wählt das erste Feld aus.
\cmdline{-r} Sortiert in umgekehrter Reihenfolge.
\cmdline{-n} Sortiert nach nummerischen Werten.
\noindent
\cmdline{man sort} Für weitere Optionen.

\subsubsection{uniq}
Doppelte Werte werden gelöscht. \textbf{Funktioniert nur bei sortierten Files!}
\cmdline{uniq ./file } Doppelte Werte löschen.
\cmdline{uniq -c ./file} Doppelte Werte löschen und die Anzahl ausgeben.

\subsubsection{awk}
\cmdinline{awk} ist eines der mächtigsten Tools für Shell Scripting.
Es beinhaltet eine eigene Script Sprache, welche Touring Complete ist.
\cmdinline{awk} wurde für Oneliner-Scripts entwickelt,
es können aber auch größere Programme damit entwicketl werden.

\cmdinline{awk} interpretiert Leer- bzw. Tabzeichen als Delimiter,
dass heißt es können wieder einzelene Felder angesprochen werden.
Jede Zeile wird, wie bei anderen Tools auch, als eigener Record gesehen.

\cmdinline{awk} Scripts können als ein File,
welches üblicherweise auf \cmdinline{.awk} endet,
übergeben werden, oder als String, welcher mit einem einfachem Hochkomma geschrieben wird.

\paragraph{Syntax}
\cmdline{awk 'contition {Action}' ./file}
Bei \cmdinline{awk} ist der erste Teil des Scripts die Contition und der zweite Teil,
welcher in geschwungenen Klammern geschrieben wird,
ist die auszuführende Aktion.
Die Contition überprüft für jede Zeile in einem File, etc ob sie darauf zutrifft.
Man kann entweder die Contition weglasse, dadurch wird die Aktion für jede Zeile ausgeführt,
oder die Aktion, damit wird einfach jede Zeile ausgegeben auf die die Contition zutrifft.

\cmdline{awk '$2 > 2 { print $0 }' ./file}
Bei diesem Script wird der Wert aus dem zweiten Feld überprüft ob dieser größer als zwei ist.
Falls diese Bedingung zu trifft, wird die ganze Zeile ausgegeben, da \mintinline{bash}{$0} den Wert der ganzen Zeile beinhaltet.

\paragraph{Aktionen}
Eine Aktion kann ein \cmdinline{print} enthalten oder auch komplexere Oneliner oder Scripts:
\cmdline{awk '$2 > 2 { print $0 > bigger_than_two.txt}' ./file}


\subsection{Environment-Variables}
Environment-Variables sind mehr oder weniger globale Variablen, welche einen bestimmten Wert beinhalten.
\begin{minted}{bash}
  HELLO="Hello, "$USER # Setzt eine Variable "Hello" für die momentane Session.
  # $USER gibt den Namen des eingeloggten User aus
  echo $HELLO # Gibt die Variable aus.
\end{minted}

\subsubsection{Für momentane Shell}
Um eine Variable nur für die momentane Shell zu setzen muss sie nur definiert werden: \bashinline{VAR="New Var"}.
Diese wird verworfen sobald die Shell geschlossen wird.

\subsubsection{Für momentane Shell und alle in ihr gestarteten Prozesse}
Diese Variable ist für alle in Shell gestarteten Prozesse verfügbar, inklusive der Shell selber:
\bashinline{export VAR="New Var"}
Dies wird durch das \cmdinline{export} Keyword erzielt.
Diese Variable wird verworfen sobald die Shell geschlossen wird.

\subsubsection{Permanente Variablen}
Um eine Variable permanent zu speichern muss sie nur in das \cmdinline{.bashrc} oder \cmdinline{.profile}, etc geschrieben werden.
Hier kann auch wieder das \cmdinline{export} Keyword angewandt werden.

\section{Regex}
\href{https://regexr.com/}{https://regexr.com/}
\begin{itemize}
\item Dot-Operator \(.\)\\
  Findet genau ein beliebiges Zeichen.
\item Asterisk \(*\)\\
  Bezieht sich auf den vorigen Operator.
  Findet 0 - n Zeichen
\item Plus-Operator \(+\)\\
  Bezieht sich auf den vorigen Operator.
  Findet 1 - n Zeichen
\item Fragezeichen-Operator \(?\)\\
  Voriger Operator kommt 0 - 1 vor.
\item Pipe-Operator \(|\)\\
  Wählt eine von zwei Möglichkeiten aus.
  oft kombiniert mit der Gruppierung.
\item Gruppierung\(()\)\\
  Gruppiert verschiedene Operatoren.
\item Auswahl \([]\)\\
  Es wird ein Zeichen ausgewählt, welches in der eckigen Klammer geschrieben wird.
\item Anfang \(\hat{}\)\\
  Wählt den Zeilenanfang aus.
  Innerhalb einer eckigen Klammer bedeutet es: alle Zeichen ausser den angegebenen.
\item Ende \(\$\)
  Wählt Zeilenende aus.
\item Newline \(\backslash n\)
\item Tab \(\backslash t\)
\item Space \(\backslash s\)
\item Wortanfang und -ende \(\backslash b\)
  
\end{itemize}

\section{Rechte}
U User Rechte.\\
G Group Rechte.\\
O Other Rechte.\\
A All Rechte.\\

\subsection{File/Folder Rechte}
\subsubsection{Folder}
\begin{itemize}
\item Read(4): Inhalt eines Ordners einsehen.
\item Write(2): Inhalt eines Ordners Löschen.
\item Execute(1): In einen Ordner hineinwechseln.
\item Sticky Bit(1):
  Nur der Besitzer eines Files/Dir darf dieses entfernen/moven.
  Beispiel: \cmdinline{/tmp}.
\item SGID(2):
  Alle Unterverzeichnisse/Files werden der Gruppe zugeordnet,
  welcher das Parentdirectory gehört.
\item SUID(4):
  Alle Unterverzeichnisse/Files werden dem Owner des Parentdirectorys zugeordnet
\end{itemize}

\subsubsection{Files}
\begin{itemize}
\item Read(4): Inhalt eines Files anzeigen.
\item Write(2): Inhalt eines Files ändern.
\item Execute(1): File ausführen(zB Script).
\item Sticky Bit(1): Wird von Linux ignoriert.
\item SGID(2): Der User hat temporär die Rechte der Gruppe, wenn ausgeführt.
\item SUID(4):
  Ein File wird mit den Rechten des Owners ausgeführt. Beispiel: \cmdinline{passwd}.
\end{itemize}

\subsubsection{Owner/Group ändern}
\begin{itemize}
\item\cmdinline{chown <user> <file/dir>} ändert den Owner.
  Mit der \cmdinline{-R} Option rekursiv.
\item\cmdinline{chgrp <group> <file/dir>} ändert die Gruppe.
\end{itemize}

\subsection{User Actions}
\subsubsection{Add User}
\cmdinline{useradd <username>} fügt einen User hinzu.
Mit der Option \cmdinline{--create-home} wird auch gleich das Home Directory erstellt.

\subsubsection{Delete User}
\cmdinline{userdel <username>} löscht einen User.
Die Option \cmdinline{-r} entfernt alle Files/Folder, welche initial erstellt wurden.

\subsection{Gruppen}
\subsubsection{Gruppe hinzufügen}
\cmdinline{groupadd <group>}

\subsubsection{Group löschen}
\cmdline{groupdel <group>}

\subsubsection{User zu Gruppe einfügen}
\cmdinline{adduser <user> <group>} einen user zu einer Gruppe hinzufügen.

\subsubsection{User aus einer Gruppe entfernen}
\cmdinline{delgroup <group>}

\section{Get Help}
\subsection{Man-Page}
Linux hat eine Bedinungsanleitung eingebaut, die sogenannte Man-Page.
Diese sind nur zu gebrauchen, wenn man das Command schon kennt.
\cmdline{man <command>}

\subsection{TL;DR}
Ein Tool mit Zusammenfassungen und Beispielen für verschieden Commands: \href{https://tldr.sh/}{https://tldr.sh}

\end{document}
