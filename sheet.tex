\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[a4paper]{geometry}
\usepackage{titling}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=cyan,
}

\usepackage{lmodern}
\usepackage{tikz}
\usepackage{minted}

\newcommand{\cmdinline}[1]{\mintinline{cmdlexer.py:CommandLexer -x}{#1}}
\newcommand{\cmdline}[1]{\mint{cmdlexer.py:CommandLexer -x}{#1}}
\newcommand{\bashinline}[1]{\mintinline{bash}{#1}}
\newcommand{\bashline}[1]{\mint{bash}{#1}}

\usemintedstyle{emacs}

\setlength{\droptitle}{-10em}
\renewcommand{\familydefault}{\sfdefault} 

\title{Linux Command Sheet}
\author{Florian Weingartshofer}
\date{\today}


\begin{document}
\maketitle
\tableofcontents{}
\newpage
\section{Basics}
\subsection{User \& Kernelspace}
\begin{tikzpicture}
  \tikzstyle{arrow} = [thick,->,>=stealth]

  %% USER SPACE
  % Left Label
  \node [draw=none] at (0,0) {User Space};
  % GNU
  \node [draw=none] at (7, 1.5) {Users (Multi-User)};
  \draw [rounded corners, fill=green!25] (3, 1) rectangle (11, -1);
  \node [draw=none] at (7, 0.8) {Programs};
  % Shell
  \draw [fill=yellow!25] (3.5, 0.5) rectangle (10.5, 0);
  \node [draw=none] at (7, 0.25) {Shell};
  % Add-Ons
  \draw (3.5, -0.1) rectangle (5, -0.6);
  \node [draw=none] at (4.25, -0.35) {Add-Ons};
  % Command & Utilities
  \draw [fill=yellow!25] (5.1, -0.1) rectangle (8.6, -0.6);
  \node [draw=none] at (6.85, -0.35) {Commands \& Utilities};
  % X/Desktops
  \draw [fill=yellow!25] (8.7, -0.1) rectangle (10.5, -0.6);
  \node [draw=none] at (9.6, -0.35) {X/Desktops};
  % libc
  \draw [rounded corners, fill=green!25] (7, -1.5) rectangle (11, -2.5);
  \draw [fill=yellow!25] (7.2, -1.75) rectangle (10.8, -2.25);
  \node [draw=none] at (9, -2.05) {GNU C Library (libc)};
  \draw [line width=1mm] (9,-1.5) -- (9, -1);
  
  % Seperator
  \draw [thick,dashed] (-1,-3) -- (14,-3);
  
  % Left Label
  \node [draw=none] at (0,-6) {Kernel Space};
  % Kernel
  \draw [rounded corners, fill=red!25] (3, -3.5) rectangle (11, -8);
  \node [draw=none] at (7, -3.7) {Kernel};
  % System Call Interface
  \draw [fill=yellow!25] (3.5, -4) rectangle (10.5, -4.5);
  \node [draw=none] at (7, -4.25) {System Call Interface};
  \draw [line width=1mm] (9,-2.5) -- (9, -4);
  \draw [line width=1mm] (5,-1) -- (5, -4);
  % Management
  \draw [fill=yellow!25] (3.5, -5) rectangle (10.5, -6);
  \node [draw=none,align=left] at (4.5, -5.5) {Process\\Management};
  \node [draw=none,align=left] at (6.5, -5.5) {Memory\\Management};
  \node [draw=none] at (7.9, -5.3) {File System};
  \node [draw=none] at (9.5, -5.25) {Network};
  % Drivers
  \draw [fill=yellow!25] (3.5, -6.5) rectangle (10.5, -7.5);
  \node [draw=none] at (7, -6.75) {Architecture Dependant Code};
  \node [draw=none] at (7, -7.25) {Device Drivers};

  % Hardware
  \node [draw=none] at (7, -8.5) {Hardware};
  
  % Outer Box
  \draw (2,2) rectangle (12,-9);
\end{tikzpicture}

\subsection{Filesystem}
Das Linux Filesystem beginnt bei Root (der Pfad lautet: \cmdinline{/}).
Von dort beginnt jeder absolute Pfad.\\
Wenn man ein Terminal startet ist man normalerweiße im Home Directory (\cmdinline{/home/<username>/}).

\subsubsection{Home Directory}
Jeder User hat ein Home Directory, dieses enthält Files welche nur für diesen User gelten, zb Configs, Bilder oder Dokumente.
Das Home Directory liegt in \cmdinline{/home/<username>/}
oder unter der Environment Variable \cmdinline{$HOME}.

\subsubsection{Die Tilde}
In den meisten Shells, wie die Bash, führt die Tilde (\cmdinline{~}) direkt ins Home Directory des Users.
Allerdings hat sie noch andere Funktionen.

\cmdline{~<username>}
Home Directory von <username>.

\cmdline{~-}
Das vorherige Working Directory.

\cmdline{~+}
Das momentane Working Directory.
\\\\
Weiter Infos:
\href{https://stackoverflow.com/questions/998626/meaning-of-tilde-in-linux-bash-not-home-directory}{https://stackoverflow.com}

\subsection{Files und Directories}
\cmdline{file.docx}
Ein normales File.

\cmdline{stuff/}
Ein normales Directory, diese enden immer auf ein \cmdinline{/}.

\cmdline{.hidden.txt}
Ein verstecktes File, sie beginnen immer mit einem Punkt.

\cmdline{.hidden_dir/}
Ein verstecktes Directory beginnt auch mit einem Punkt.

\cmdline{.}
Ein Punkt zeigt nur das momentane Directory an.

\cmdline{..}
Zwei Punkte zeigen das Parent-Directory an.

\subsection{Wichtige Files und Directories}
Folgende Files und Directories können im \cmdinline{$HOME} Directory gefunden werden.
\subsubsection{.bashrc}
Das \cmdinline{.bashrc} File ist ein Bash-Script, welches beim öffnen eines Terminals ausgeführt wird.
Man kann es nutzen um Environment Variablen, Aliases zu setzen oder andere Einstellungen vorzunehmen.
Es können auch Splashscreens oder Nachrichten ausgegeben werden.

\begin{minted}{cmdlexer.py:CommandLexer -x}
  echo "Das heutige Wetter"
  curl wttr.in # Download the weather
\end{minted}

\subsubsection{.zshrc}
Ein Init Script für die Z-Shell. Hat die selbe Funktionalität wie das \cmdinline{.bashrc}.

\subsubsection{.config/}
Das \cmdinline{.config/} Directory ist ein Ordner im \cmdinline{.config/}
In diesem Directory werden einige Config-Files gespeichert.

\subsubsection{.profile}
Dieses File befindet sich im Home-Directory jedes Benutzers, es existiert auch ein globals in \cmdinline{/etc/profile}.
Es wird von der Bash und oft auch von Desktop-Environments ausgeführt.

\subsection{Aufbau eines Commands}
Ein Command besteht aus verschiedenen Komponenten:

\begin{minted}{cmdlexer.py:CommandLexer -x}
ls --all -l /home/
\end{minted}

\cmdline{ls} Das Command selbst

\cmdline{--all}
Eine ausgeschriebene Option, diese beginnen mit einem doppeltem Minus.

\cmdline{-l}
Die Kurzform einer Option, wird nur mit einem Minus geschrieben.

\cmdline{/home/}
Ein Argument, manche Commands können mehrere Argumente erhalten.

\subsection{Adminrechte}
Um einen Befehl als Admin auszuführen muss der \cmdinline{sudo} Befehl genutzt werden.

\cmdline{sudo <Befehl>}

\noindent
Beispiel:
\cmdline{sudo rm <file>}

\subsection{Navigieren}
Mit \cmdinline{cd} kann im Terminal navigiert werden.

\cmdline{cd path/to/dir/}
In ein Directory wechseln.

\cmdline{cd}
Wechselt ins Home-Directory.

\cmdline{cd ..}
Ins Parent-Directory wechseln.

\cmdline{cd -}
Ins vorherige Directory wechseln.

\subsection{Files auflisten}
\cmdline{pwd}
Zeigt absoluten Pfad zum momentanen Directory an.

\cmdline{ls}
Zeigt Files und Directories im momentanen Ordner an.

\cmdline{ls <directory>}
Zeigt Files in einem Directory an.

\cmdline{ls -l}
Zeigt Files, etc in einer Listenstruktur an.

\cmdline{ls -a}
Zeigt \textbf{alle} Files und Ordner an, auch versteckte.

\cmdline{ls -h}
Zeigt alle von Menschen lesbare Dateien und Directories an.

\cmdline{ls -la}
Es können auch verschiedene Optionen kombiniert werden.

\subsection{Erstellen von Directories}

\cmdline{mkdir <directory>}
Ein Directory im momentanen Directory erstellen.

\cmdline{mkdir /path/to/dir/newdir/}
Es kann auch ein Directory mit einem Pfad angegeben werden.

Dabei ist das letzte Directory, dass das nur erstellt wird.

\cmdline{mkdir -p new/dir}
Mit der p-Flag können auch Subdirectories rekursiv erstellt werden.

\cmdline{mkdir {dir1,dir2,dir3}}
Mit den geschwungene Klammern können mehrer Directories gleichzeitig erstellt werden.

\cmdline{mkdir -p new/{dir1,dir2,dir3}}
Die Directories können auch rekursiv in einem Parent-Directory erstellt werden.

\subsection{Erstellen von Files}

\cmdline{touch </path/to/file.txt>}
Mit \cmdinline{touch} kann ein File erstellt werden.

Falls das File schon exisitiert wird das Datum aktualisiert.

\cmdline{touch {file1,file2,file3}}
So können mehrere Files erstellt werden.

\subsection{Files Löschen}
\cmdline{rm <file>}
Mit \cmdinline{rm} kann ein oder mehrere Files löschen.

\cmdline{rm -r <dir/>}
Mit der r-Flag können auch Directories entfernt werden.

\cmdline{rm -f <file>}
Um ein File zwingend zu löschen wird die f-Flag benötigt.

\subsection{Files verschieben}
\cmdline{mv <arg1> <arg2>}
Mit \cmdinline{mv} kann ein File oder Directory verschoben oder umbenannt werden.

Vergleichbar mit Cut and Paste.

\subsection{Files kopieren}
\cmdline{cp <path/to/file.txt> <path/to/new/file>}

Mit \cmdinline{cp} können Files oder Directories kopiert werden.

\subsection{Alias}
Mit Aliases kann man Commands abkürzen.

\cmdline{alias hello='clear && echo "Hello"'}

\subsection{dos2unix}
\cmdinline{dos2unix} ist kein Standardpaket und muss daher installiert werden.
Es ist ein einfaches Tool, um DOS(Windows) Newlines zu Unix Newlines zu konvertieren. 

\section{Packagemanager}
Im Gegensatz zu Windows braucht man bei Linux keine Software manuell runterzuladen.
Dies wird automatisch mit einem Packagemanager gemacht.

\subsection{apt}
Das Advanced Packaging Tool(\cmdinline{apt}) ist ein Tool um Packages auf Debian, Ubuntu, etc zu installieren.

\subsubsection{Packages installieren}
Um ein Package zu installieren werden meistens Admin Rechte benötigt,
daher muss vor dem Command ein \cmdinline{sudo} geschrieben werden.

\cmdline{apt install <Package_1 Package_2 ... Package_n>}

\subsubsection{Packages suchen}
\cmdline{apt search <Package>}

\subsubsection{Packages entfernen}
Dieses Command muss auch als Super User ausgeführt werden.
\cmdline{apt remove <Package>}

\section{Scripting}
\subsection{Piping}
Um Output als Input für ein anderes Programm zu nutzen, muss die Pipe verwendet werden (\cmdinline{|}).

\subsection{Ausgabeumleitung}
Output kann auch in verschiedene Files umgeleitet werden, diese werden automatisch angelegt:
\begin{minted}{bash}
  echo "Hello" > hello.txt  # Das File wird komplett überschrieben beim Umleiten.
  echo "Hello" >> hello.txt # Der Text wird am Ende des Files angefügt,
                            # sollte es schon Daten beinhalten.
\end{minted}

\subsection{Text-Editing Tools}
Folgende Tools können zum manipulieren von Texten verwendet werden, speziell für CSV Files sind diese nützlich.
Die meisten dieser Tools sind einheitlich aufgebaut:
\cmdline{wc -l path/to/text/file}
Als erstes wird das Command eingegeben, dann verschiedene Optionen und schluss endlich das Textfile, welches genutzt wird.
\subsubsection{wc}
Ein einfaches Tool zum Zählen von Zeichen, Zeilen, Wörtern, etc.
\begin{minted}{cmdlexer.py:CommandLexer -x}
  wc -l ./file # Zählt die Zeilen des Files
  wc -w ./file # Anzahl der Wörter
  man wc # Für weitere Optionen
\end{minted}

\subsubsection{tail}
Ein Tool um die letzten n-Zeilen eines Files auszugeben.
\cmdline{tail -n3 ./file }
\noindent
Die Wörter in der letzten Zeile zählen:
\cmdline{tail -n1 ./file | wc -w }

\subsubsection{head}
Mit diesen Tool können die Anfangszeilen eines Files ausgegeben werden.
\cmdline{head -n3 ./file # Die ersten drei Zeilen }
\cmdline{head -3l ./file # Ident mit der -n Option }

\subsubsection{cut}
\cmdinline{cut} entfernt bestimmte Felder einer Datei, diese ist meist im CSV Format.
Das Standardtrennzeichen ist ein Tab.
\cmdline{cut -d'|' -f1,3 ./file }
\noindent
\cmdinline{-d';'} setzt das Trennzeichen auf ein Semicolon.\\
\cmdinline{-f1,3} Wählt das erste und dritte Feld aus.

\subsubsection{sort}
\cmdinline{sort} sortiert ein File zeilenweise.
\cmdline{sort -t'|' -k1 -r -n ./file }
\noindent
\cmdline{-t'|'} Setzt das Trennzeichen auf eine Pipe.
\cmdline{-k1} Wählt das erste Feld aus.
\cmdline{-r} Sortiert in umgekehrter Reihenfolge.
\cmdline{-n} Sortiert nach nummerischen Werten.
\noindent
\cmdline{man sort} Für weitere Optionen.

\subsubsection{uniq}
Doppelte Werte werden gelöscht. \textbf{Funktioniert nur bei sortierten Files!}
\cmdline{uniq ./file } Doppelte Werte löschen.
\cmdline{uniq -c ./file} Doppelte Werte löschen und die Anzahl ausgeben.

\subsection{Environment-Variables}
Environment-Variables sind mehr oder weniger globale Variablen, welche einen bestimmten Wert beinhalten.
\begin{minted}{bash}
  HELLO="Hello, "$USER # Setzt eine Variable "Hello" für die momentane Session.
  # $USER gibt den Namen des eingeloggten User aus
  echo $HELLO # Gibt die Variable aus.
\end{minted}

\subsubsection{Für momentane Shell}
Um eine Variable nur für die momentane Shell zu setzen muss sie nur definiert werden: \bashinline{VAR="New Var"}.
Diese wird verworfen sobald die Shell geschlossen wird.

\subsubsection{Für momentane Shell und alle in ihr gestarteten Prozesse}
Diese Variable ist für alle in Shell gestarteten Prozesse verfügbar, inklusive der Shell selber:
\bashinline{export VAR="New Var"}
Dies wird durch das \cmdinline{export} Keyword gemacht.
Diese Variable wird verworfen sobald die Shell geschlossen wird.

\subsubsection{Permanente Variablen}
Um eine Variable permanent zu speichern muss sie nur in das \cmdinline{.bashrc} oder \cmdinline{.profile}, etc geschrieben werden.
Hier kann auch wieder das \cmdinline{export} Keyword angewandt werden.

\section{Get Help}
\subsection{Man-Page}
Linux hat eine Bedinungsanleitung eingebaut, die sogenannte Man-Page.
Diese sind nur zu gebrauchen, wenn man das Command schon kennt.
\cmdline{man <command>}

\subsection{TL;DR}
Ein Tool mit Zusammenfassungen und Beispielen für verschieden Commands: \href{https://tldr.sh/}{https://tldr.sh}

\end{document}
